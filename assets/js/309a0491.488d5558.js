"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[9026],{5768(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"how-to/sampling/use-sampling","title":"Use sampling","description":"The smpl package helps you make a consistent sampling decision (sampled vs. not sampled) and store it in a context.Context. Other gosoline packages can then use that decision to change behavior (e.g. reduce log volume).","source":"@site/docs/how-to/sampling/use-sampling.mdx","sourceDirName":"how-to/sampling","slug":"/how-to/sampling/use-sampling","permalink":"/gosoline/how-to/sampling/use-sampling","draft":false,"unlisted":false,"editUrl":"https://github.com/justtrackio/gosoline/tree/main/docs/docs/how-to/sampling/use-sampling.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Use sampling"},"sidebar":"docSidebar","previous":{"title":"How to use the Kafka Schema Registry","permalink":"/gosoline/how-to/kafka/use-schema-registry"},"next":{"title":"Implement health checks","permalink":"/gosoline/how-to/write-health-checks"}}');var s=i(4848),r=i(8453),a=i(3457);const l={sidebar_position:1,title:"Use sampling"},o=void 0,c={},d=[{value:"Concepts",id:"concepts",level:2},{value:"Default behavior",id:"default-behavior",level:3},{value:"Configuration",id:"configuration",level:2},{value:"Built-in strategies",id:"built-in-strategies",level:3},{value:"Probabilistic settings",id:"probabilistic-settings",level:4},{value:"Make a decision",id:"make-a-decision",level:2},{value:"Override per call with additional strategies",id:"override-per-call-with-additional-strategies",level:2},{value:"Register a custom strategy for config",id:"register-a-custom-strategy-for-config",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2}];function g(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"smpl"})," package helps you make a consistent sampling decision (sampled vs. not sampled) and store it in a ",(0,s.jsx)(n.code,{children:"context.Context"}),". Other gosoline packages can then use that decision to change behavior (e.g. reduce log volume)."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["This guide focuses only on the sampling packages. If you want to see how sampling interacts with buffering logs on errors, read: ",(0,s.jsx)(n.a,{href:"/how-to/logging/sampling-and-fingers-crossed",children:"Sampling & fingers-crossed"}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"concepts",children:"Concepts"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.strong,{children:"strategy"})," is a small function that can make a sampling decision based on the current context."]}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.strong,{children:"decider"})," applies strategies in order and stores the final decision in the context."]}),"\n",(0,s.jsx)(n.li,{children:"The decision lives on the context and can be read from anywhere down the call chain."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"default-behavior",children:"Default behavior"}),"\n",(0,s.jsxs)(n.p,{children:["If there is no sampling decision on the context, gosoline treats it as ",(0,s.jsx)(n.strong,{children:"sampled"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["That means ",(0,s.jsx)(n.code,{children:"smplctx.IsSampled(ctx)"})," returns ",(0,s.jsx)(n.code,{children:"true"})," by default."]}),"\n",(0,s.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["The sampling decider reads its settings from the ",(0,s.jsx)(n.code,{children:"sampling"})," config key."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"sampling:\n  enabled: true\n  strategies:\n    - tracing\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sampling.enabled"}),": if set to ",(0,s.jsx)(n.code,{children:"false"}),", the decider behaves as if everything is sampled."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sampling.strategies"}),": list of strategy names in priority order. The first strategy that applies wins."]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["When sampling is enabled and a new decision is made, gosoline emits a metric ",(0,s.jsx)(n.code,{children:"sampling_decision"})," (count) with dimension ",(0,s.jsx)(n.code,{children:"sampled=true|false"}),"."]})}),"\n",(0,s.jsx)(n.h3,{id:"built-in-strategies",children:"Built-in strategies"}),"\n",(0,s.jsx)(n.p,{children:"Gosoline ships with a few strategies you can reference by name:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tracing"}),": if a trace is present in the context, use its sampling flag."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"always"}),": always sample."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"never"}),": never sample."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"probabilistic"}),": guarantees at least one sampled decision per time window and additionally samples a small percentage of extra traffic."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"probabilistic-settings",children:"Probabilistic settings"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"probabilistic"})," strategy reads its settings from ",(0,s.jsx)(n.code,{children:"sampling.settings.probabilistic"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"sampling:\n  enabled: true\n  strategies:\n    - probabilistic\n  settings:\n    probabilistic:\n      interval: 1s\n      fixed_sample_count: 1\n      extra_rate_percentage: 5\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"interval"}),": time window for the per-interval guarantee."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fixed_sample_count"}),": number of guaranteed ",(0,s.jsx)(n.code,{children:"sampled=true"})," decisions per interval."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"extra_rate_percentage"}),": probability (0\u2013100) for sampling additional calls within the same interval."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"make-a-decision",children:"Make a decision"}),"\n",(0,s.jsx)(n.p,{children:"Typical flow:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Create (or provide) a decider."}),"\n",(0,s.jsxs)(n.li,{children:["Call ",(0,s.jsx)(n.code,{children:"Decide"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Use the returned context for the rest of your work."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The returned context is important because this is where the decision is stored."}),"\n",(0,s.jsx)(a.A,{showLineNumbers:!0,language:"go",title:"main.go",children:'package main\n\nimport (\n\t"context"\n\t"fmt"\n\n\t"github.com/justtrackio/gosoline/pkg/cfg"\n\t"github.com/justtrackio/gosoline/pkg/log"\n\t"github.com/justtrackio/gosoline/pkg/smpl"\n\t"github.com/justtrackio/gosoline/pkg/smpl/smplctx"\n)\n\ntype ctxKey string\n\nfunc init() {\n\t// Register a custom sampling strategy that can be referenced in config.\n\t//\n\t// This is process-global and should be done before application startup, before a decider is created.\n\tsmpl.AddStrategy("force-by-context", func(ctx context.Context, config cfg.Config) (smpl.Strategy, error) {\n\t\treturn func(ctx context.Context) (applied bool, sampled bool, err error) {\n\t\t\tif v, ok := ctx.Value(ctxKey("force_sample")).(bool); ok {\n\t\t\t\treturn true, v, nil\n\t\t\t}\n\n\t\t\treturn false, false, nil\n\t\t}, nil\n\t})\n}\n\nfunc main() {\n\tctx := context.Background()\n\tconfig := cfg.New()\n\tlogger := log.NewLogger()\n\n\t// Pretend this is coming from an incoming request/message.\n\tctx = context.WithValue(ctx, ctxKey("force_sample"), false)\n\n\t// Build a decider from config. It reads `sampling.enabled` and `sampling.strategies`.\n\t// In real applications you typically use smpl.ProvideDecider(ctx, config).\n\tdecider, err := smpl.NewDecider(ctx, config)\n\tif err != nil {\n\t\tlogger.Error(ctx, "can not create decider: %w", err)\n\n\t\treturn\n\t}\n\n\t// Decide applies the configured strategies.\n\tctx, sampled, err := decider.Decide(ctx)\n\tif err != nil {\n\t\tlogger.Error(ctx, "can not decide: %w", err)\n\n\t\treturn\n\t}\n\n\tfmt.Printf("config decision: sampled=%v (smplctx.IsSampled=%v)\\n", sampled, smplctx.IsSampled(ctx))\n\n\t// Per-call overrides: additional strategies run before the configured strategies.\n\t// This allows you to force sampling behaviour for specific code paths.\n\talwaysStrategy, err := smpl.DecideByAlways(ctx, config)\n\tif err != nil {\n\t\tlogger.Error(ctx, "can not build override strategy: %w", err)\n\n\t\treturn\n\t}\n\n\tctx, sampled, err = decider.Decide(ctx, alwaysStrategy)\n\tif err != nil {\n\t\tlogger.Error(ctx, "can not decide with override: %w", err)\n\n\t\treturn\n\t}\n\n\tfmt.Printf("override decision: sampled=%v (smplctx.IsSampled=%v)\\n", sampled, smplctx.IsSampled(ctx))\n}\n'}),"\n",(0,s.jsx)(n.h2,{id:"override-per-call-with-additional-strategies",children:"Override per call with additional strategies"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Decide(ctx, additionalStrategies...)"})," lets you influence the decision for a specific code path."]}),"\n",(0,s.jsxs)(n.p,{children:["Additional strategies are applied ",(0,s.jsx)(n.strong,{children:"before"})," the configured ones. This is useful when you need more control in a single place, without changing global config."]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Force sampling for a specific operation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"always, _ := smpl.DecideByAlways(ctx, config)\nctx, sampled, err := decider.Decide(ctx, always)\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Force not-sampled behavior:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"never, _ := smpl.DecideByNever(ctx, config)\nctx, sampled, err := decider.Decide(ctx, never)\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If your additional strategy can not decide, return ",(0,s.jsx)(n.code,{children:"applied=false"})," so the configured strategies can decide."]}),"\n",(0,s.jsxs)(n.p,{children:["A common example is HTTP request sampling: you can derive a strategy from the incoming request and pass it as an additional strategy (so it takes precedence over config). Gosoline's HTTP server middleware does this using the ",(0,s.jsx)(n.code,{children:"X-Goso-Sampled"})," header."]}),"\n",(0,s.jsx)(n.h2,{id:"register-a-custom-strategy-for-config",children:"Register a custom strategy for config"}),"\n",(0,s.jsxs)(n.p,{children:["If you want to make a strategy configurable (usable via ",(0,s.jsx)(n.code,{children:"sampling.strategies"}),"), register it with ",(0,s.jsx)(n.code,{children:"smpl.AddStrategy(name, strategy)"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"This is process-global."}),"\n",(0,s.jsx)(n.li,{children:"Register strategies during application startup (before building the decider), so config parsing can resolve the strategy name."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example pattern:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'smpl.AddStrategy("my-strategy", func(ctx context.Context, config cfg.Config) (smpl.Strategy, error) {\n\treturn func(ctx context.Context) (applied bool, sampled bool, err error) {\n\t\t// Decide on certain contexts, otherwise abstain.\n\t\treturn false, false, nil\n\t}, nil\n})\n'})}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:'"It always says sampled"'}),": if ",(0,s.jsx)(n.code,{children:"sampling.enabled"})," is ",(0,s.jsx)(n.code,{children:"false"})," or no decision is stored, ",(0,s.jsx)(n.code,{children:"smplctx.IsSampled(ctx)"})," returns ",(0,s.jsx)(n.code,{children:"true"})," by default."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:'"My strategy does nothing"'}),": some strategies only apply if required data exists on the context (e.g. ",(0,s.jsx)(n.code,{children:"tracing"})," needs a trace in the context)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:'"I called Decide but later code doesn\'t see it"'}),": ensure you propagate the returned context (",(0,s.jsx)(n.code,{children:"ctx = newCtx"}),")."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(g,{...e})}):g(e)}}}]);