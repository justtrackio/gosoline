// Code generated by mockery v2.22.1. DO NOT EDIT.

package mocks

import (
	context "context"

	kinesis "github.com/aws/aws-sdk-go-v2/service/kinesis"
	mock "github.com/stretchr/testify/mock"
)

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

// AddTagsToStream provides a mock function with given fields: ctx, params, optFns
func (_m *Client) AddTagsToStream(ctx context.Context, params *kinesis.AddTagsToStreamInput, optFns ...func(*kinesis.Options)) (*kinesis.AddTagsToStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.AddTagsToStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.AddTagsToStreamInput, ...func(*kinesis.Options)) (*kinesis.AddTagsToStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.AddTagsToStreamInput, ...func(*kinesis.Options)) *kinesis.AddTagsToStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.AddTagsToStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.AddTagsToStreamInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateStream provides a mock function with given fields: ctx, params, optFns
func (_m *Client) CreateStream(ctx context.Context, params *kinesis.CreateStreamInput, optFns ...func(*kinesis.Options)) (*kinesis.CreateStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.CreateStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.CreateStreamInput, ...func(*kinesis.Options)) (*kinesis.CreateStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.CreateStreamInput, ...func(*kinesis.Options)) *kinesis.CreateStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.CreateStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.CreateStreamInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DecreaseStreamRetentionPeriod provides a mock function with given fields: ctx, params, optFns
func (_m *Client) DecreaseStreamRetentionPeriod(ctx context.Context, params *kinesis.DecreaseStreamRetentionPeriodInput, optFns ...func(*kinesis.Options)) (*kinesis.DecreaseStreamRetentionPeriodOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.DecreaseStreamRetentionPeriodOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DecreaseStreamRetentionPeriodInput, ...func(*kinesis.Options)) (*kinesis.DecreaseStreamRetentionPeriodOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DecreaseStreamRetentionPeriodInput, ...func(*kinesis.Options)) *kinesis.DecreaseStreamRetentionPeriodOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DecreaseStreamRetentionPeriodOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DecreaseStreamRetentionPeriodInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteStream provides a mock function with given fields: ctx, params, optFns
func (_m *Client) DeleteStream(ctx context.Context, params *kinesis.DeleteStreamInput, optFns ...func(*kinesis.Options)) (*kinesis.DeleteStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.DeleteStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DeleteStreamInput, ...func(*kinesis.Options)) (*kinesis.DeleteStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DeleteStreamInput, ...func(*kinesis.Options)) *kinesis.DeleteStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DeleteStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DeleteStreamInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterStreamConsumer provides a mock function with given fields: ctx, params, optFns
func (_m *Client) DeregisterStreamConsumer(ctx context.Context, params *kinesis.DeregisterStreamConsumerInput, optFns ...func(*kinesis.Options)) (*kinesis.DeregisterStreamConsumerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.DeregisterStreamConsumerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DeregisterStreamConsumerInput, ...func(*kinesis.Options)) (*kinesis.DeregisterStreamConsumerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DeregisterStreamConsumerInput, ...func(*kinesis.Options)) *kinesis.DeregisterStreamConsumerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DeregisterStreamConsumerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DeregisterStreamConsumerInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLimits provides a mock function with given fields: ctx, params, optFns
func (_m *Client) DescribeLimits(ctx context.Context, params *kinesis.DescribeLimitsInput, optFns ...func(*kinesis.Options)) (*kinesis.DescribeLimitsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.DescribeLimitsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DescribeLimitsInput, ...func(*kinesis.Options)) (*kinesis.DescribeLimitsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DescribeLimitsInput, ...func(*kinesis.Options)) *kinesis.DescribeLimitsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DescribeLimitsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DescribeLimitsInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStream provides a mock function with given fields: ctx, params, optFns
func (_m *Client) DescribeStream(ctx context.Context, params *kinesis.DescribeStreamInput, optFns ...func(*kinesis.Options)) (*kinesis.DescribeStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.DescribeStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DescribeStreamInput, ...func(*kinesis.Options)) (*kinesis.DescribeStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DescribeStreamInput, ...func(*kinesis.Options)) *kinesis.DescribeStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DescribeStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DescribeStreamInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStreamConsumer provides a mock function with given fields: ctx, params, optFns
func (_m *Client) DescribeStreamConsumer(ctx context.Context, params *kinesis.DescribeStreamConsumerInput, optFns ...func(*kinesis.Options)) (*kinesis.DescribeStreamConsumerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.DescribeStreamConsumerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DescribeStreamConsumerInput, ...func(*kinesis.Options)) (*kinesis.DescribeStreamConsumerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DescribeStreamConsumerInput, ...func(*kinesis.Options)) *kinesis.DescribeStreamConsumerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DescribeStreamConsumerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DescribeStreamConsumerInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStreamSummary provides a mock function with given fields: ctx, params, optFns
func (_m *Client) DescribeStreamSummary(ctx context.Context, params *kinesis.DescribeStreamSummaryInput, optFns ...func(*kinesis.Options)) (*kinesis.DescribeStreamSummaryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.DescribeStreamSummaryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DescribeStreamSummaryInput, ...func(*kinesis.Options)) (*kinesis.DescribeStreamSummaryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DescribeStreamSummaryInput, ...func(*kinesis.Options)) *kinesis.DescribeStreamSummaryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DescribeStreamSummaryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DescribeStreamSummaryInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableEnhancedMonitoring provides a mock function with given fields: ctx, params, optFns
func (_m *Client) DisableEnhancedMonitoring(ctx context.Context, params *kinesis.DisableEnhancedMonitoringInput, optFns ...func(*kinesis.Options)) (*kinesis.DisableEnhancedMonitoringOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.DisableEnhancedMonitoringOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DisableEnhancedMonitoringInput, ...func(*kinesis.Options)) (*kinesis.DisableEnhancedMonitoringOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DisableEnhancedMonitoringInput, ...func(*kinesis.Options)) *kinesis.DisableEnhancedMonitoringOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DisableEnhancedMonitoringOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DisableEnhancedMonitoringInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableEnhancedMonitoring provides a mock function with given fields: ctx, params, optFns
func (_m *Client) EnableEnhancedMonitoring(ctx context.Context, params *kinesis.EnableEnhancedMonitoringInput, optFns ...func(*kinesis.Options)) (*kinesis.EnableEnhancedMonitoringOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.EnableEnhancedMonitoringOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.EnableEnhancedMonitoringInput, ...func(*kinesis.Options)) (*kinesis.EnableEnhancedMonitoringOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.EnableEnhancedMonitoringInput, ...func(*kinesis.Options)) *kinesis.EnableEnhancedMonitoringOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.EnableEnhancedMonitoringOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.EnableEnhancedMonitoringInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRecords provides a mock function with given fields: ctx, params, optFns
func (_m *Client) GetRecords(ctx context.Context, params *kinesis.GetRecordsInput, optFns ...func(*kinesis.Options)) (*kinesis.GetRecordsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.GetRecordsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.GetRecordsInput, ...func(*kinesis.Options)) (*kinesis.GetRecordsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.GetRecordsInput, ...func(*kinesis.Options)) *kinesis.GetRecordsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.GetRecordsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.GetRecordsInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetShardIterator provides a mock function with given fields: ctx, params, optFns
func (_m *Client) GetShardIterator(ctx context.Context, params *kinesis.GetShardIteratorInput, optFns ...func(*kinesis.Options)) (*kinesis.GetShardIteratorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.GetShardIteratorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.GetShardIteratorInput, ...func(*kinesis.Options)) (*kinesis.GetShardIteratorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.GetShardIteratorInput, ...func(*kinesis.Options)) *kinesis.GetShardIteratorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.GetShardIteratorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.GetShardIteratorInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IncreaseStreamRetentionPeriod provides a mock function with given fields: ctx, params, optFns
func (_m *Client) IncreaseStreamRetentionPeriod(ctx context.Context, params *kinesis.IncreaseStreamRetentionPeriodInput, optFns ...func(*kinesis.Options)) (*kinesis.IncreaseStreamRetentionPeriodOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.IncreaseStreamRetentionPeriodOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.IncreaseStreamRetentionPeriodInput, ...func(*kinesis.Options)) (*kinesis.IncreaseStreamRetentionPeriodOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.IncreaseStreamRetentionPeriodInput, ...func(*kinesis.Options)) *kinesis.IncreaseStreamRetentionPeriodOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.IncreaseStreamRetentionPeriodOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.IncreaseStreamRetentionPeriodInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListShards provides a mock function with given fields: ctx, params, optFns
func (_m *Client) ListShards(ctx context.Context, params *kinesis.ListShardsInput, optFns ...func(*kinesis.Options)) (*kinesis.ListShardsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.ListShardsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.ListShardsInput, ...func(*kinesis.Options)) (*kinesis.ListShardsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.ListShardsInput, ...func(*kinesis.Options)) *kinesis.ListShardsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.ListShardsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.ListShardsInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStreamConsumers provides a mock function with given fields: ctx, params, optFns
func (_m *Client) ListStreamConsumers(ctx context.Context, params *kinesis.ListStreamConsumersInput, optFns ...func(*kinesis.Options)) (*kinesis.ListStreamConsumersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.ListStreamConsumersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.ListStreamConsumersInput, ...func(*kinesis.Options)) (*kinesis.ListStreamConsumersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.ListStreamConsumersInput, ...func(*kinesis.Options)) *kinesis.ListStreamConsumersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.ListStreamConsumersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.ListStreamConsumersInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStreams provides a mock function with given fields: ctx, params, optFns
func (_m *Client) ListStreams(ctx context.Context, params *kinesis.ListStreamsInput, optFns ...func(*kinesis.Options)) (*kinesis.ListStreamsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.ListStreamsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.ListStreamsInput, ...func(*kinesis.Options)) (*kinesis.ListStreamsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.ListStreamsInput, ...func(*kinesis.Options)) *kinesis.ListStreamsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.ListStreamsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.ListStreamsInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForStream provides a mock function with given fields: ctx, params, optFns
func (_m *Client) ListTagsForStream(ctx context.Context, params *kinesis.ListTagsForStreamInput, optFns ...func(*kinesis.Options)) (*kinesis.ListTagsForStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.ListTagsForStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.ListTagsForStreamInput, ...func(*kinesis.Options)) (*kinesis.ListTagsForStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.ListTagsForStreamInput, ...func(*kinesis.Options)) *kinesis.ListTagsForStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.ListTagsForStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.ListTagsForStreamInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergeShards provides a mock function with given fields: ctx, params, optFns
func (_m *Client) MergeShards(ctx context.Context, params *kinesis.MergeShardsInput, optFns ...func(*kinesis.Options)) (*kinesis.MergeShardsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.MergeShardsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.MergeShardsInput, ...func(*kinesis.Options)) (*kinesis.MergeShardsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.MergeShardsInput, ...func(*kinesis.Options)) *kinesis.MergeShardsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.MergeShardsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.MergeShardsInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutRecord provides a mock function with given fields: ctx, params, optFns
func (_m *Client) PutRecord(ctx context.Context, params *kinesis.PutRecordInput, optFns ...func(*kinesis.Options)) (*kinesis.PutRecordOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.PutRecordOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.PutRecordInput, ...func(*kinesis.Options)) (*kinesis.PutRecordOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.PutRecordInput, ...func(*kinesis.Options)) *kinesis.PutRecordOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.PutRecordOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.PutRecordInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutRecords provides a mock function with given fields: ctx, params, optFns
func (_m *Client) PutRecords(ctx context.Context, params *kinesis.PutRecordsInput, optFns ...func(*kinesis.Options)) (*kinesis.PutRecordsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.PutRecordsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.PutRecordsInput, ...func(*kinesis.Options)) (*kinesis.PutRecordsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.PutRecordsInput, ...func(*kinesis.Options)) *kinesis.PutRecordsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.PutRecordsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.PutRecordsInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterStreamConsumer provides a mock function with given fields: ctx, params, optFns
func (_m *Client) RegisterStreamConsumer(ctx context.Context, params *kinesis.RegisterStreamConsumerInput, optFns ...func(*kinesis.Options)) (*kinesis.RegisterStreamConsumerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.RegisterStreamConsumerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.RegisterStreamConsumerInput, ...func(*kinesis.Options)) (*kinesis.RegisterStreamConsumerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.RegisterStreamConsumerInput, ...func(*kinesis.Options)) *kinesis.RegisterStreamConsumerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.RegisterStreamConsumerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.RegisterStreamConsumerInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveTagsFromStream provides a mock function with given fields: ctx, params, optFns
func (_m *Client) RemoveTagsFromStream(ctx context.Context, params *kinesis.RemoveTagsFromStreamInput, optFns ...func(*kinesis.Options)) (*kinesis.RemoveTagsFromStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.RemoveTagsFromStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.RemoveTagsFromStreamInput, ...func(*kinesis.Options)) (*kinesis.RemoveTagsFromStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.RemoveTagsFromStreamInput, ...func(*kinesis.Options)) *kinesis.RemoveTagsFromStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.RemoveTagsFromStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.RemoveTagsFromStreamInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SplitShard provides a mock function with given fields: ctx, params, optFns
func (_m *Client) SplitShard(ctx context.Context, params *kinesis.SplitShardInput, optFns ...func(*kinesis.Options)) (*kinesis.SplitShardOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.SplitShardOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.SplitShardInput, ...func(*kinesis.Options)) (*kinesis.SplitShardOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.SplitShardInput, ...func(*kinesis.Options)) *kinesis.SplitShardOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.SplitShardOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.SplitShardInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartStreamEncryption provides a mock function with given fields: ctx, params, optFns
func (_m *Client) StartStreamEncryption(ctx context.Context, params *kinesis.StartStreamEncryptionInput, optFns ...func(*kinesis.Options)) (*kinesis.StartStreamEncryptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.StartStreamEncryptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.StartStreamEncryptionInput, ...func(*kinesis.Options)) (*kinesis.StartStreamEncryptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.StartStreamEncryptionInput, ...func(*kinesis.Options)) *kinesis.StartStreamEncryptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.StartStreamEncryptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.StartStreamEncryptionInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopStreamEncryption provides a mock function with given fields: ctx, params, optFns
func (_m *Client) StopStreamEncryption(ctx context.Context, params *kinesis.StopStreamEncryptionInput, optFns ...func(*kinesis.Options)) (*kinesis.StopStreamEncryptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.StopStreamEncryptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.StopStreamEncryptionInput, ...func(*kinesis.Options)) (*kinesis.StopStreamEncryptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.StopStreamEncryptionInput, ...func(*kinesis.Options)) *kinesis.StopStreamEncryptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.StopStreamEncryptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.StopStreamEncryptionInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubscribeToShard provides a mock function with given fields: ctx, params, optFns
func (_m *Client) SubscribeToShard(ctx context.Context, params *kinesis.SubscribeToShardInput, optFns ...func(*kinesis.Options)) (*kinesis.SubscribeToShardOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.SubscribeToShardOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.SubscribeToShardInput, ...func(*kinesis.Options)) (*kinesis.SubscribeToShardOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.SubscribeToShardInput, ...func(*kinesis.Options)) *kinesis.SubscribeToShardOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.SubscribeToShardOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.SubscribeToShardInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateShardCount provides a mock function with given fields: ctx, params, optFns
func (_m *Client) UpdateShardCount(ctx context.Context, params *kinesis.UpdateShardCountInput, optFns ...func(*kinesis.Options)) (*kinesis.UpdateShardCountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.UpdateShardCountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.UpdateShardCountInput, ...func(*kinesis.Options)) (*kinesis.UpdateShardCountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.UpdateShardCountInput, ...func(*kinesis.Options)) *kinesis.UpdateShardCountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.UpdateShardCountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.UpdateShardCountInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateStreamMode provides a mock function with given fields: ctx, params, optFns
func (_m *Client) UpdateStreamMode(ctx context.Context, params *kinesis.UpdateStreamModeInput, optFns ...func(*kinesis.Options)) (*kinesis.UpdateStreamModeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kinesis.UpdateStreamModeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.UpdateStreamModeInput, ...func(*kinesis.Options)) (*kinesis.UpdateStreamModeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.UpdateStreamModeInput, ...func(*kinesis.Options)) *kinesis.UpdateStreamModeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.UpdateStreamModeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.UpdateStreamModeInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewClient(t mockConstructorTestingTNewClient) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
