// Code generated by mockery v2.53.0. DO NOT EDIT.

package mocks

import (
	context "context"

	glue "github.com/aws/aws-sdk-go-v2/service/glue"
	mock "github.com/stretchr/testify/mock"
)

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

type Client_Expecter struct {
	mock *mock.Mock
}

func (_m *Client) EXPECT() *Client_Expecter {
	return &Client_Expecter{mock: &_m.Mock}
}

// BatchCreatePartition provides a mock function with given fields: ctx, params, optFns
func (_m *Client) BatchCreatePartition(ctx context.Context, params *glue.BatchCreatePartitionInput, optFns ...func(*glue.Options)) (*glue.BatchCreatePartitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchCreatePartition")
	}

	var r0 *glue.BatchCreatePartitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchCreatePartitionInput, ...func(*glue.Options)) (*glue.BatchCreatePartitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchCreatePartitionInput, ...func(*glue.Options)) *glue.BatchCreatePartitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchCreatePartitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchCreatePartitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_BatchCreatePartition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchCreatePartition'
type Client_BatchCreatePartition_Call struct {
	*mock.Call
}

// BatchCreatePartition is a helper method to define mock.On call
//   - ctx context.Context
//   - params *glue.BatchCreatePartitionInput
//   - optFns ...func(*glue.Options)
func (_e *Client_Expecter) BatchCreatePartition(ctx interface{}, params interface{}, optFns ...interface{}) *Client_BatchCreatePartition_Call {
	return &Client_BatchCreatePartition_Call{Call: _e.mock.On("BatchCreatePartition",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *Client_BatchCreatePartition_Call) Run(run func(ctx context.Context, params *glue.BatchCreatePartitionInput, optFns ...func(*glue.Options))) *Client_BatchCreatePartition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*glue.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*glue.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*glue.BatchCreatePartitionInput), variadicArgs...)
	})
	return _c
}

func (_c *Client_BatchCreatePartition_Call) Return(_a0 *glue.BatchCreatePartitionOutput, _a1 error) *Client_BatchCreatePartition_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_BatchCreatePartition_Call) RunAndReturn(run func(context.Context, *glue.BatchCreatePartitionInput, ...func(*glue.Options)) (*glue.BatchCreatePartitionOutput, error)) *Client_BatchCreatePartition_Call {
	_c.Call.Return(run)
	return _c
}

// BatchDeletePartition provides a mock function with given fields: ctx, params, optFns
func (_m *Client) BatchDeletePartition(ctx context.Context, params *glue.BatchDeletePartitionInput, optFns ...func(*glue.Options)) (*glue.BatchDeletePartitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeletePartition")
	}

	var r0 *glue.BatchDeletePartitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchDeletePartitionInput, ...func(*glue.Options)) (*glue.BatchDeletePartitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchDeletePartitionInput, ...func(*glue.Options)) *glue.BatchDeletePartitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchDeletePartitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchDeletePartitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_BatchDeletePartition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchDeletePartition'
type Client_BatchDeletePartition_Call struct {
	*mock.Call
}

// BatchDeletePartition is a helper method to define mock.On call
//   - ctx context.Context
//   - params *glue.BatchDeletePartitionInput
//   - optFns ...func(*glue.Options)
func (_e *Client_Expecter) BatchDeletePartition(ctx interface{}, params interface{}, optFns ...interface{}) *Client_BatchDeletePartition_Call {
	return &Client_BatchDeletePartition_Call{Call: _e.mock.On("BatchDeletePartition",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *Client_BatchDeletePartition_Call) Run(run func(ctx context.Context, params *glue.BatchDeletePartitionInput, optFns ...func(*glue.Options))) *Client_BatchDeletePartition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*glue.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*glue.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*glue.BatchDeletePartitionInput), variadicArgs...)
	})
	return _c
}

func (_c *Client_BatchDeletePartition_Call) Return(_a0 *glue.BatchDeletePartitionOutput, _a1 error) *Client_BatchDeletePartition_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_BatchDeletePartition_Call) RunAndReturn(run func(context.Context, *glue.BatchDeletePartitionInput, ...func(*glue.Options)) (*glue.BatchDeletePartitionOutput, error)) *Client_BatchDeletePartition_Call {
	_c.Call.Return(run)
	return _c
}

// BatchGetPartition provides a mock function with given fields: ctx, params, optFns
func (_m *Client) BatchGetPartition(ctx context.Context, params *glue.BatchGetPartitionInput, optFns ...func(*glue.Options)) (*glue.BatchGetPartitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetPartition")
	}

	var r0 *glue.BatchGetPartitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetPartitionInput, ...func(*glue.Options)) (*glue.BatchGetPartitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetPartitionInput, ...func(*glue.Options)) *glue.BatchGetPartitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchGetPartitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchGetPartitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_BatchGetPartition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchGetPartition'
type Client_BatchGetPartition_Call struct {
	*mock.Call
}

// BatchGetPartition is a helper method to define mock.On call
//   - ctx context.Context
//   - params *glue.BatchGetPartitionInput
//   - optFns ...func(*glue.Options)
func (_e *Client_Expecter) BatchGetPartition(ctx interface{}, params interface{}, optFns ...interface{}) *Client_BatchGetPartition_Call {
	return &Client_BatchGetPartition_Call{Call: _e.mock.On("BatchGetPartition",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *Client_BatchGetPartition_Call) Run(run func(ctx context.Context, params *glue.BatchGetPartitionInput, optFns ...func(*glue.Options))) *Client_BatchGetPartition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*glue.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*glue.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*glue.BatchGetPartitionInput), variadicArgs...)
	})
	return _c
}

func (_c *Client_BatchGetPartition_Call) Return(_a0 *glue.BatchGetPartitionOutput, _a1 error) *Client_BatchGetPartition_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_BatchGetPartition_Call) RunAndReturn(run func(context.Context, *glue.BatchGetPartitionInput, ...func(*glue.Options)) (*glue.BatchGetPartitionOutput, error)) *Client_BatchGetPartition_Call {
	_c.Call.Return(run)
	return _c
}

// BatchUpdatePartition provides a mock function with given fields: ctx, params, optFns
func (_m *Client) BatchUpdatePartition(ctx context.Context, params *glue.BatchUpdatePartitionInput, optFns ...func(*glue.Options)) (*glue.BatchUpdatePartitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchUpdatePartition")
	}

	var r0 *glue.BatchUpdatePartitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchUpdatePartitionInput, ...func(*glue.Options)) (*glue.BatchUpdatePartitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchUpdatePartitionInput, ...func(*glue.Options)) *glue.BatchUpdatePartitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchUpdatePartitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchUpdatePartitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_BatchUpdatePartition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchUpdatePartition'
type Client_BatchUpdatePartition_Call struct {
	*mock.Call
}

// BatchUpdatePartition is a helper method to define mock.On call
//   - ctx context.Context
//   - params *glue.BatchUpdatePartitionInput
//   - optFns ...func(*glue.Options)
func (_e *Client_Expecter) BatchUpdatePartition(ctx interface{}, params interface{}, optFns ...interface{}) *Client_BatchUpdatePartition_Call {
	return &Client_BatchUpdatePartition_Call{Call: _e.mock.On("BatchUpdatePartition",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *Client_BatchUpdatePartition_Call) Run(run func(ctx context.Context, params *glue.BatchUpdatePartitionInput, optFns ...func(*glue.Options))) *Client_BatchUpdatePartition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*glue.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*glue.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*glue.BatchUpdatePartitionInput), variadicArgs...)
	})
	return _c
}

func (_c *Client_BatchUpdatePartition_Call) Return(_a0 *glue.BatchUpdatePartitionOutput, _a1 error) *Client_BatchUpdatePartition_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_BatchUpdatePartition_Call) RunAndReturn(run func(context.Context, *glue.BatchUpdatePartitionInput, ...func(*glue.Options)) (*glue.BatchUpdatePartitionOutput, error)) *Client_BatchUpdatePartition_Call {
	_c.Call.Return(run)
	return _c
}

// CreateDatabase provides a mock function with given fields: ctx, params, optFns
func (_m *Client) CreateDatabase(ctx context.Context, params *glue.CreateDatabaseInput, optFns ...func(*glue.Options)) (*glue.CreateDatabaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDatabase")
	}

	var r0 *glue.CreateDatabaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateDatabaseInput, ...func(*glue.Options)) (*glue.CreateDatabaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateDatabaseInput, ...func(*glue.Options)) *glue.CreateDatabaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateDatabaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateDatabaseInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_CreateDatabase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDatabase'
type Client_CreateDatabase_Call struct {
	*mock.Call
}

// CreateDatabase is a helper method to define mock.On call
//   - ctx context.Context
//   - params *glue.CreateDatabaseInput
//   - optFns ...func(*glue.Options)
func (_e *Client_Expecter) CreateDatabase(ctx interface{}, params interface{}, optFns ...interface{}) *Client_CreateDatabase_Call {
	return &Client_CreateDatabase_Call{Call: _e.mock.On("CreateDatabase",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *Client_CreateDatabase_Call) Run(run func(ctx context.Context, params *glue.CreateDatabaseInput, optFns ...func(*glue.Options))) *Client_CreateDatabase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*glue.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*glue.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*glue.CreateDatabaseInput), variadicArgs...)
	})
	return _c
}

func (_c *Client_CreateDatabase_Call) Return(_a0 *glue.CreateDatabaseOutput, _a1 error) *Client_CreateDatabase_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_CreateDatabase_Call) RunAndReturn(run func(context.Context, *glue.CreateDatabaseInput, ...func(*glue.Options)) (*glue.CreateDatabaseOutput, error)) *Client_CreateDatabase_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTable provides a mock function with given fields: ctx, params, optFns
func (_m *Client) CreateTable(ctx context.Context, params *glue.CreateTableInput, optFns ...func(*glue.Options)) (*glue.CreateTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTable")
	}

	var r0 *glue.CreateTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateTableInput, ...func(*glue.Options)) (*glue.CreateTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateTableInput, ...func(*glue.Options)) *glue.CreateTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateTableInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_CreateTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTable'
type Client_CreateTable_Call struct {
	*mock.Call
}

// CreateTable is a helper method to define mock.On call
//   - ctx context.Context
//   - params *glue.CreateTableInput
//   - optFns ...func(*glue.Options)
func (_e *Client_Expecter) CreateTable(ctx interface{}, params interface{}, optFns ...interface{}) *Client_CreateTable_Call {
	return &Client_CreateTable_Call{Call: _e.mock.On("CreateTable",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *Client_CreateTable_Call) Run(run func(ctx context.Context, params *glue.CreateTableInput, optFns ...func(*glue.Options))) *Client_CreateTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*glue.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*glue.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*glue.CreateTableInput), variadicArgs...)
	})
	return _c
}

func (_c *Client_CreateTable_Call) Return(_a0 *glue.CreateTableOutput, _a1 error) *Client_CreateTable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_CreateTable_Call) RunAndReturn(run func(context.Context, *glue.CreateTableInput, ...func(*glue.Options)) (*glue.CreateTableOutput, error)) *Client_CreateTable_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteDatabase provides a mock function with given fields: ctx, params, optFns
func (_m *Client) DeleteDatabase(ctx context.Context, params *glue.DeleteDatabaseInput, optFns ...func(*glue.Options)) (*glue.DeleteDatabaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDatabase")
	}

	var r0 *glue.DeleteDatabaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteDatabaseInput, ...func(*glue.Options)) (*glue.DeleteDatabaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteDatabaseInput, ...func(*glue.Options)) *glue.DeleteDatabaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteDatabaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteDatabaseInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_DeleteDatabase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteDatabase'
type Client_DeleteDatabase_Call struct {
	*mock.Call
}

// DeleteDatabase is a helper method to define mock.On call
//   - ctx context.Context
//   - params *glue.DeleteDatabaseInput
//   - optFns ...func(*glue.Options)
func (_e *Client_Expecter) DeleteDatabase(ctx interface{}, params interface{}, optFns ...interface{}) *Client_DeleteDatabase_Call {
	return &Client_DeleteDatabase_Call{Call: _e.mock.On("DeleteDatabase",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *Client_DeleteDatabase_Call) Run(run func(ctx context.Context, params *glue.DeleteDatabaseInput, optFns ...func(*glue.Options))) *Client_DeleteDatabase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*glue.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*glue.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*glue.DeleteDatabaseInput), variadicArgs...)
	})
	return _c
}

func (_c *Client_DeleteDatabase_Call) Return(_a0 *glue.DeleteDatabaseOutput, _a1 error) *Client_DeleteDatabase_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_DeleteDatabase_Call) RunAndReturn(run func(context.Context, *glue.DeleteDatabaseInput, ...func(*glue.Options)) (*glue.DeleteDatabaseOutput, error)) *Client_DeleteDatabase_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePartition provides a mock function with given fields: ctx, params, optFns
func (_m *Client) DeletePartition(ctx context.Context, params *glue.DeletePartitionInput, optFns ...func(*glue.Options)) (*glue.DeletePartitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePartition")
	}

	var r0 *glue.DeletePartitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeletePartitionInput, ...func(*glue.Options)) (*glue.DeletePartitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeletePartitionInput, ...func(*glue.Options)) *glue.DeletePartitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeletePartitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeletePartitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_DeletePartition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePartition'
type Client_DeletePartition_Call struct {
	*mock.Call
}

// DeletePartition is a helper method to define mock.On call
//   - ctx context.Context
//   - params *glue.DeletePartitionInput
//   - optFns ...func(*glue.Options)
func (_e *Client_Expecter) DeletePartition(ctx interface{}, params interface{}, optFns ...interface{}) *Client_DeletePartition_Call {
	return &Client_DeletePartition_Call{Call: _e.mock.On("DeletePartition",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *Client_DeletePartition_Call) Run(run func(ctx context.Context, params *glue.DeletePartitionInput, optFns ...func(*glue.Options))) *Client_DeletePartition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*glue.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*glue.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*glue.DeletePartitionInput), variadicArgs...)
	})
	return _c
}

func (_c *Client_DeletePartition_Call) Return(_a0 *glue.DeletePartitionOutput, _a1 error) *Client_DeletePartition_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_DeletePartition_Call) RunAndReturn(run func(context.Context, *glue.DeletePartitionInput, ...func(*glue.Options)) (*glue.DeletePartitionOutput, error)) *Client_DeletePartition_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTable provides a mock function with given fields: ctx, params, optFns
func (_m *Client) DeleteTable(ctx context.Context, params *glue.DeleteTableInput, optFns ...func(*glue.Options)) (*glue.DeleteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTable")
	}

	var r0 *glue.DeleteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteTableInput, ...func(*glue.Options)) (*glue.DeleteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteTableInput, ...func(*glue.Options)) *glue.DeleteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteTableInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_DeleteTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTable'
type Client_DeleteTable_Call struct {
	*mock.Call
}

// DeleteTable is a helper method to define mock.On call
//   - ctx context.Context
//   - params *glue.DeleteTableInput
//   - optFns ...func(*glue.Options)
func (_e *Client_Expecter) DeleteTable(ctx interface{}, params interface{}, optFns ...interface{}) *Client_DeleteTable_Call {
	return &Client_DeleteTable_Call{Call: _e.mock.On("DeleteTable",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *Client_DeleteTable_Call) Run(run func(ctx context.Context, params *glue.DeleteTableInput, optFns ...func(*glue.Options))) *Client_DeleteTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*glue.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*glue.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*glue.DeleteTableInput), variadicArgs...)
	})
	return _c
}

func (_c *Client_DeleteTable_Call) Return(_a0 *glue.DeleteTableOutput, _a1 error) *Client_DeleteTable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_DeleteTable_Call) RunAndReturn(run func(context.Context, *glue.DeleteTableInput, ...func(*glue.Options)) (*glue.DeleteTableOutput, error)) *Client_DeleteTable_Call {
	_c.Call.Return(run)
	return _c
}

// GetDatabase provides a mock function with given fields: ctx, params, optFns
func (_m *Client) GetDatabase(ctx context.Context, params *glue.GetDatabaseInput, optFns ...func(*glue.Options)) (*glue.GetDatabaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDatabase")
	}

	var r0 *glue.GetDatabaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDatabaseInput, ...func(*glue.Options)) (*glue.GetDatabaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDatabaseInput, ...func(*glue.Options)) *glue.GetDatabaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetDatabaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetDatabaseInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_GetDatabase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDatabase'
type Client_GetDatabase_Call struct {
	*mock.Call
}

// GetDatabase is a helper method to define mock.On call
//   - ctx context.Context
//   - params *glue.GetDatabaseInput
//   - optFns ...func(*glue.Options)
func (_e *Client_Expecter) GetDatabase(ctx interface{}, params interface{}, optFns ...interface{}) *Client_GetDatabase_Call {
	return &Client_GetDatabase_Call{Call: _e.mock.On("GetDatabase",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *Client_GetDatabase_Call) Run(run func(ctx context.Context, params *glue.GetDatabaseInput, optFns ...func(*glue.Options))) *Client_GetDatabase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*glue.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*glue.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*glue.GetDatabaseInput), variadicArgs...)
	})
	return _c
}

func (_c *Client_GetDatabase_Call) Return(_a0 *glue.GetDatabaseOutput, _a1 error) *Client_GetDatabase_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_GetDatabase_Call) RunAndReturn(run func(context.Context, *glue.GetDatabaseInput, ...func(*glue.Options)) (*glue.GetDatabaseOutput, error)) *Client_GetDatabase_Call {
	_c.Call.Return(run)
	return _c
}

// GetDatabases provides a mock function with given fields: ctx, params, optFns
func (_m *Client) GetDatabases(ctx context.Context, params *glue.GetDatabasesInput, optFns ...func(*glue.Options)) (*glue.GetDatabasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDatabases")
	}

	var r0 *glue.GetDatabasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDatabasesInput, ...func(*glue.Options)) (*glue.GetDatabasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDatabasesInput, ...func(*glue.Options)) *glue.GetDatabasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetDatabasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetDatabasesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_GetDatabases_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDatabases'
type Client_GetDatabases_Call struct {
	*mock.Call
}

// GetDatabases is a helper method to define mock.On call
//   - ctx context.Context
//   - params *glue.GetDatabasesInput
//   - optFns ...func(*glue.Options)
func (_e *Client_Expecter) GetDatabases(ctx interface{}, params interface{}, optFns ...interface{}) *Client_GetDatabases_Call {
	return &Client_GetDatabases_Call{Call: _e.mock.On("GetDatabases",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *Client_GetDatabases_Call) Run(run func(ctx context.Context, params *glue.GetDatabasesInput, optFns ...func(*glue.Options))) *Client_GetDatabases_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*glue.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*glue.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*glue.GetDatabasesInput), variadicArgs...)
	})
	return _c
}

func (_c *Client_GetDatabases_Call) Return(_a0 *glue.GetDatabasesOutput, _a1 error) *Client_GetDatabases_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_GetDatabases_Call) RunAndReturn(run func(context.Context, *glue.GetDatabasesInput, ...func(*glue.Options)) (*glue.GetDatabasesOutput, error)) *Client_GetDatabases_Call {
	_c.Call.Return(run)
	return _c
}

// GetPartition provides a mock function with given fields: ctx, params, optFns
func (_m *Client) GetPartition(ctx context.Context, params *glue.GetPartitionInput, optFns ...func(*glue.Options)) (*glue.GetPartitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPartition")
	}

	var r0 *glue.GetPartitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetPartitionInput, ...func(*glue.Options)) (*glue.GetPartitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetPartitionInput, ...func(*glue.Options)) *glue.GetPartitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetPartitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetPartitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_GetPartition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPartition'
type Client_GetPartition_Call struct {
	*mock.Call
}

// GetPartition is a helper method to define mock.On call
//   - ctx context.Context
//   - params *glue.GetPartitionInput
//   - optFns ...func(*glue.Options)
func (_e *Client_Expecter) GetPartition(ctx interface{}, params interface{}, optFns ...interface{}) *Client_GetPartition_Call {
	return &Client_GetPartition_Call{Call: _e.mock.On("GetPartition",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *Client_GetPartition_Call) Run(run func(ctx context.Context, params *glue.GetPartitionInput, optFns ...func(*glue.Options))) *Client_GetPartition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*glue.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*glue.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*glue.GetPartitionInput), variadicArgs...)
	})
	return _c
}

func (_c *Client_GetPartition_Call) Return(_a0 *glue.GetPartitionOutput, _a1 error) *Client_GetPartition_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_GetPartition_Call) RunAndReturn(run func(context.Context, *glue.GetPartitionInput, ...func(*glue.Options)) (*glue.GetPartitionOutput, error)) *Client_GetPartition_Call {
	_c.Call.Return(run)
	return _c
}

// GetPartitions provides a mock function with given fields: ctx, params, optFns
func (_m *Client) GetPartitions(ctx context.Context, params *glue.GetPartitionsInput, optFns ...func(*glue.Options)) (*glue.GetPartitionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPartitions")
	}

	var r0 *glue.GetPartitionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetPartitionsInput, ...func(*glue.Options)) (*glue.GetPartitionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetPartitionsInput, ...func(*glue.Options)) *glue.GetPartitionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetPartitionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetPartitionsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_GetPartitions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPartitions'
type Client_GetPartitions_Call struct {
	*mock.Call
}

// GetPartitions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *glue.GetPartitionsInput
//   - optFns ...func(*glue.Options)
func (_e *Client_Expecter) GetPartitions(ctx interface{}, params interface{}, optFns ...interface{}) *Client_GetPartitions_Call {
	return &Client_GetPartitions_Call{Call: _e.mock.On("GetPartitions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *Client_GetPartitions_Call) Run(run func(ctx context.Context, params *glue.GetPartitionsInput, optFns ...func(*glue.Options))) *Client_GetPartitions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*glue.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*glue.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*glue.GetPartitionsInput), variadicArgs...)
	})
	return _c
}

func (_c *Client_GetPartitions_Call) Return(_a0 *glue.GetPartitionsOutput, _a1 error) *Client_GetPartitions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_GetPartitions_Call) RunAndReturn(run func(context.Context, *glue.GetPartitionsInput, ...func(*glue.Options)) (*glue.GetPartitionsOutput, error)) *Client_GetPartitions_Call {
	_c.Call.Return(run)
	return _c
}

// GetTable provides a mock function with given fields: ctx, params, optFns
func (_m *Client) GetTable(ctx context.Context, params *glue.GetTableInput, optFns ...func(*glue.Options)) (*glue.GetTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTable")
	}

	var r0 *glue.GetTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTableInput, ...func(*glue.Options)) (*glue.GetTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTableInput, ...func(*glue.Options)) *glue.GetTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetTableInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_GetTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTable'
type Client_GetTable_Call struct {
	*mock.Call
}

// GetTable is a helper method to define mock.On call
//   - ctx context.Context
//   - params *glue.GetTableInput
//   - optFns ...func(*glue.Options)
func (_e *Client_Expecter) GetTable(ctx interface{}, params interface{}, optFns ...interface{}) *Client_GetTable_Call {
	return &Client_GetTable_Call{Call: _e.mock.On("GetTable",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *Client_GetTable_Call) Run(run func(ctx context.Context, params *glue.GetTableInput, optFns ...func(*glue.Options))) *Client_GetTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*glue.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*glue.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*glue.GetTableInput), variadicArgs...)
	})
	return _c
}

func (_c *Client_GetTable_Call) Return(_a0 *glue.GetTableOutput, _a1 error) *Client_GetTable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_GetTable_Call) RunAndReturn(run func(context.Context, *glue.GetTableInput, ...func(*glue.Options)) (*glue.GetTableOutput, error)) *Client_GetTable_Call {
	_c.Call.Return(run)
	return _c
}

// GetTables provides a mock function with given fields: ctx, params, optFns
func (_m *Client) GetTables(ctx context.Context, params *glue.GetTablesInput, optFns ...func(*glue.Options)) (*glue.GetTablesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTables")
	}

	var r0 *glue.GetTablesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTablesInput, ...func(*glue.Options)) (*glue.GetTablesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTablesInput, ...func(*glue.Options)) *glue.GetTablesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetTablesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetTablesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_GetTables_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTables'
type Client_GetTables_Call struct {
	*mock.Call
}

// GetTables is a helper method to define mock.On call
//   - ctx context.Context
//   - params *glue.GetTablesInput
//   - optFns ...func(*glue.Options)
func (_e *Client_Expecter) GetTables(ctx interface{}, params interface{}, optFns ...interface{}) *Client_GetTables_Call {
	return &Client_GetTables_Call{Call: _e.mock.On("GetTables",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *Client_GetTables_Call) Run(run func(ctx context.Context, params *glue.GetTablesInput, optFns ...func(*glue.Options))) *Client_GetTables_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*glue.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*glue.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*glue.GetTablesInput), variadicArgs...)
	})
	return _c
}

func (_c *Client_GetTables_Call) Return(_a0 *glue.GetTablesOutput, _a1 error) *Client_GetTables_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_GetTables_Call) RunAndReturn(run func(context.Context, *glue.GetTablesInput, ...func(*glue.Options)) (*glue.GetTablesOutput, error)) *Client_GetTables_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateDatabase provides a mock function with given fields: ctx, params, optFns
func (_m *Client) UpdateDatabase(ctx context.Context, params *glue.UpdateDatabaseInput, optFns ...func(*glue.Options)) (*glue.UpdateDatabaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDatabase")
	}

	var r0 *glue.UpdateDatabaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateDatabaseInput, ...func(*glue.Options)) (*glue.UpdateDatabaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateDatabaseInput, ...func(*glue.Options)) *glue.UpdateDatabaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateDatabaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateDatabaseInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_UpdateDatabase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateDatabase'
type Client_UpdateDatabase_Call struct {
	*mock.Call
}

// UpdateDatabase is a helper method to define mock.On call
//   - ctx context.Context
//   - params *glue.UpdateDatabaseInput
//   - optFns ...func(*glue.Options)
func (_e *Client_Expecter) UpdateDatabase(ctx interface{}, params interface{}, optFns ...interface{}) *Client_UpdateDatabase_Call {
	return &Client_UpdateDatabase_Call{Call: _e.mock.On("UpdateDatabase",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *Client_UpdateDatabase_Call) Run(run func(ctx context.Context, params *glue.UpdateDatabaseInput, optFns ...func(*glue.Options))) *Client_UpdateDatabase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*glue.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*glue.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*glue.UpdateDatabaseInput), variadicArgs...)
	})
	return _c
}

func (_c *Client_UpdateDatabase_Call) Return(_a0 *glue.UpdateDatabaseOutput, _a1 error) *Client_UpdateDatabase_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_UpdateDatabase_Call) RunAndReturn(run func(context.Context, *glue.UpdateDatabaseInput, ...func(*glue.Options)) (*glue.UpdateDatabaseOutput, error)) *Client_UpdateDatabase_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePartition provides a mock function with given fields: ctx, params, optFns
func (_m *Client) UpdatePartition(ctx context.Context, params *glue.UpdatePartitionInput, optFns ...func(*glue.Options)) (*glue.UpdatePartitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePartition")
	}

	var r0 *glue.UpdatePartitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdatePartitionInput, ...func(*glue.Options)) (*glue.UpdatePartitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdatePartitionInput, ...func(*glue.Options)) *glue.UpdatePartitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdatePartitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdatePartitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_UpdatePartition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePartition'
type Client_UpdatePartition_Call struct {
	*mock.Call
}

// UpdatePartition is a helper method to define mock.On call
//   - ctx context.Context
//   - params *glue.UpdatePartitionInput
//   - optFns ...func(*glue.Options)
func (_e *Client_Expecter) UpdatePartition(ctx interface{}, params interface{}, optFns ...interface{}) *Client_UpdatePartition_Call {
	return &Client_UpdatePartition_Call{Call: _e.mock.On("UpdatePartition",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *Client_UpdatePartition_Call) Run(run func(ctx context.Context, params *glue.UpdatePartitionInput, optFns ...func(*glue.Options))) *Client_UpdatePartition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*glue.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*glue.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*glue.UpdatePartitionInput), variadicArgs...)
	})
	return _c
}

func (_c *Client_UpdatePartition_Call) Return(_a0 *glue.UpdatePartitionOutput, _a1 error) *Client_UpdatePartition_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_UpdatePartition_Call) RunAndReturn(run func(context.Context, *glue.UpdatePartitionInput, ...func(*glue.Options)) (*glue.UpdatePartitionOutput, error)) *Client_UpdatePartition_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTable provides a mock function with given fields: ctx, params, optFns
func (_m *Client) UpdateTable(ctx context.Context, params *glue.UpdateTableInput, optFns ...func(*glue.Options)) (*glue.UpdateTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTable")
	}

	var r0 *glue.UpdateTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateTableInput, ...func(*glue.Options)) (*glue.UpdateTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateTableInput, ...func(*glue.Options)) *glue.UpdateTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateTableInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_UpdateTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTable'
type Client_UpdateTable_Call struct {
	*mock.Call
}

// UpdateTable is a helper method to define mock.On call
//   - ctx context.Context
//   - params *glue.UpdateTableInput
//   - optFns ...func(*glue.Options)
func (_e *Client_Expecter) UpdateTable(ctx interface{}, params interface{}, optFns ...interface{}) *Client_UpdateTable_Call {
	return &Client_UpdateTable_Call{Call: _e.mock.On("UpdateTable",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *Client_UpdateTable_Call) Run(run func(ctx context.Context, params *glue.UpdateTableInput, optFns ...func(*glue.Options))) *Client_UpdateTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*glue.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*glue.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*glue.UpdateTableInput), variadicArgs...)
	})
	return _c
}

func (_c *Client_UpdateTable_Call) Return(_a0 *glue.UpdateTableOutput, _a1 error) *Client_UpdateTable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_UpdateTable_Call) RunAndReturn(run func(context.Context, *glue.UpdateTableInput, ...func(*glue.Options)) (*glue.UpdateTableOutput, error)) *Client_UpdateTable_Call {
	_c.Call.Return(run)
	return _c
}

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
