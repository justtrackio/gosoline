---
sidebar_position: 1
title: Use sampling
---

import CodeBlock from '@theme/CodeBlock';
import UseSampling from "!!raw-loader!./src/use-sampling/main.go";

The `smpl` package helps you make a consistent sampling decision (sampled vs. not sampled) and store it in a `context.Context`. Other gosoline packages can then use that decision to change behavior (e.g. reduce log volume).

:::info

This guide focuses only on the sampling packages. If you want to see how sampling interacts with buffering logs on errors, read: [Sampling & fingers-crossed](/how-to/logging/sampling-and-fingers-crossed).

:::

## Concepts

- A **strategy** is a small function that can make a sampling decision based on the current context.
- A **decider** applies strategies in order and stores the final decision in the context.
- The decision lives on the context and can be read from anywhere down the call chain.

### Default behavior

If there is no sampling decision on the context, gosoline treats it as **sampled**.

That means `smplctx.IsSampled(ctx)` returns `true` by default.

## Configuration

The sampling decider reads its settings from the `sampling` config key.

```yaml
sampling:
  enabled: true
  strategies:
    - tracing
```

- `sampling.enabled`: if set to `false`, the decider behaves as if everything is sampled.
- `sampling.strategies`: list of strategy names in priority order. The first strategy that applies wins.

### Built-in strategies

Gosoline ships with a few strategies you can reference by name:

- `tracing`: if a trace is present in the context, use its sampling flag.
- `always`: always sample.
- `never`: never sample.

## Make a decision

Typical flow:

1. Create (or provide) a decider.
2. Call `Decide`.
3. Use the returned context for the rest of your work.

The returned context is important because this is where the decision is stored.

<CodeBlock showLineNumbers language="go" title="main.go">{UseSampling}</CodeBlock>

## Override per call with additional strategies

`Decide(ctx, additionalStrategies...)` lets you influence the decision for a specific code path.

Additional strategies are applied **before** the configured ones. This is useful when you need more control in a single place, without changing global config.

For example:

- Force sampling for a specific operation: `decider.Decide(ctx, smpl.DecideByAlways)`
- Force not-sampled behavior: `decider.Decide(ctx, smpl.DecideByNever)`

If your additional strategy can not decide, return `applied=false` so the configured strategies can decide.

## Register a custom strategy for config

If you want to make a strategy configurable (usable via `sampling.strategies`), register it with `smpl.AddStrategy(name, strategy)`.

- This is process-global.
- Register strategies during application startup (before building the decider), so config parsing can resolve the strategy name.

Example pattern:

```go
smpl.AddStrategy("my-strategy", func(ctx context.Context) (applied bool, sampled bool, err error) {
	// Decide on certain contexts, otherwise abstain.
	return false, false, nil
})
```

## Troubleshooting

- **"It always says sampled"**: if `sampling.enabled` is `false` or no decision is stored, `smplctx.IsSampled(ctx)` returns `true` by default.
- **"My strategy does nothing"**: some strategies only apply if required data exists on the context (e.g. `tracing` needs a trace in the context).
- **"I called Decide but later code doesn't see it"**: ensure you propagate the returned context (`ctx = newCtx`).
